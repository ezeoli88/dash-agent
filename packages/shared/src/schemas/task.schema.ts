import { z } from 'zod';

/**
 * Valid task statuses representing the lifecycle of a task in the two-agent system.
 *
 * Flow:
 * draft -> refining -> pending_approval -> approved -> coding -> review -> done
 *   |        |             |              |          |         |
 * User    PM Agent     User reads/   User      Dev Agent   User
 * writes  generates    edits spec   approves  executes    reviews PR
 * idea    spec                      spec      spec
 *
 * Legacy statuses (for backward compatibility):
 * - backlog: Maps to 'draft' - user has idea but hasn't started
 * - planning: Maps to 'refining' - PM Agent working
 * - in_progress: Maps to 'coding' - Dev Agent working
 * - awaiting_review: Maps to 'review' - PR ready for review
 * - approved: User approved the spec, Dev Agent should start
 * - pr_created: PR has been created on GitHub
 * - changes_requested: User requested changes on the PR
 * - done: PR merged, task complete
 * - failed: Error occurred
 */
export const TASK_STATUSES = [
  // New two-agent workflow statuses
  'draft',              // User writing idea
  'refining',           // PM Agent generating spec
  'pending_approval',   // Waiting for user to approve/edit spec
  'approved',           // Spec approved, in queue for Dev Agent
  'coding',             // Dev Agent working
  'review',             // PR created, waiting for review
  'changes_requested',  // User requested changes on PR
  'done',               // PR merged
  'failed',             // Error occurred
  // Legacy statuses (for backward compatibility)
  'backlog',            // Legacy: same as draft
  'planning',           // Legacy: same as refining
  'in_progress',        // Legacy: same as coding
  'awaiting_review',    // Legacy: same as review
  'pr_created',         // Legacy: PR created on GitHub
] as const;

/**
 * Zod schema for task status validation
 */
export const TaskStatusSchema = z.enum(TASK_STATUSES);

/**
 * Task status type inferred from the schema
 */
export type TaskStatus = z.infer<typeof TaskStatusSchema>;

/**
 * Complete Task entity schema with two-agent workflow fields
 */
export const TaskSchema = z.object({
  id: z.string().uuid(),

  // Legacy fields (still supported)
  title: z.string().min(1),
  description: z.string().min(1),
  repo_url: z.string().url(),
  target_branch: z.string().default('main'),
  context_files: z.array(z.string()).default([]),
  build_command: z.string().nullable(),

  // New two-agent workflow fields
  repository_id: z.string().uuid().nullable(),  // Link to repositories table

  // User input (Step 1 - Draft)
  user_input: z.string().nullable(),            // Raw user idea/request

  // PM Agent output (Step 2 - Spec Generation)
  generated_spec: z.string().nullable(),        // Spec generated by PM Agent (markdown)
  generated_spec_at: z.string().datetime().nullable(),

  // Final approved spec (Step 3 - Approval)
  final_spec: z.string().nullable(),            // May be edited by user
  spec_approved_at: z.string().datetime().nullable(),
  was_spec_edited: z.boolean().default(false),  // true if user modified the generated spec

  // Dev Agent output (Step 4 - Coding)
  branch_name: z.string().nullable(),
  pr_url: z.string().url().nullable(),
  pr_number: z.number().nullable(),

  // Status and metadata
  status: TaskStatusSchema,
  error: z.string().nullable(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});

/**
 * Task type inferred from the schema
 */
export type Task = z.infer<typeof TaskSchema>;

/**
 * Schema for creating a new task in the two-agent workflow.
 * User provides a repository and a simple idea/request.
 */
export const CreateTaskSchema = z.object({
  // Required: select a repository
  repository_id: z.string().uuid('Repository is required'),

  // Required: user's idea/request
  user_input: z.string().min(5, 'Please describe what you need (at least 5 characters)'),

  // Optional: legacy fields for backward compatibility
  title: z.string().min(1).max(200).optional(),
  description: z.string().min(10).optional(),
  repo_url: z.string().url().regex(/github\.com/).optional(),
  target_branch: z.string().optional().default('main'),
  context_files: z.array(z.string()).optional().default([]),
  build_command: z.string().optional(),
});

/**
 * Input type for creating a task
 */
export type CreateTaskInput = z.infer<typeof CreateTaskSchema>;

/**
 * Schema for updating an existing task.
 */
export const UpdateTaskSchema = z.object({
  title: z.string().min(1, 'Title must be non-empty').optional(),
  description: z.string().min(1, 'Description must be non-empty').optional(),
  repo_url: z.string().url('Repository URL must be a valid URL').optional(),
  target_branch: z.string().optional(),
  context_files: z.array(z.string()).optional(),
  build_command: z.string().nullable().optional(),
  status: TaskStatusSchema.optional(),
  pr_url: z.string().url().nullable().optional(),
  pr_number: z.number().nullable().optional(),
  branch_name: z.string().nullable().optional(),
  error: z.string().nullable().optional(),
  // Two-agent workflow fields
  user_input: z.string().nullable().optional(),
  generated_spec: z.string().nullable().optional(),
  generated_spec_at: z.string().datetime().nullable().optional(),
  final_spec: z.string().nullable().optional(),
  spec_approved_at: z.string().datetime().nullable().optional(),
  was_spec_edited: z.boolean().optional(),
  repository_id: z.string().uuid().nullable().optional(),
});

/**
 * Input type for updating a task
 */
export type UpdateTaskInput = z.infer<typeof UpdateTaskSchema>;

/**
 * Schema for the generate-spec endpoint request
 */
export const GenerateSpecRequestSchema = z.object({
  // Optional: custom instructions for the PM Agent
  additional_context: z.string().optional(),
});
export type GenerateSpecRequest = z.infer<typeof GenerateSpecRequestSchema>;

/**
 * Schema for the generate-spec endpoint response
 */
export const GenerateSpecResponseSchema = z.object({
  spec: z.string(),
  model_used: z.string(),
  tokens_used: z.number(),
});
export type GenerateSpecResponse = z.infer<typeof GenerateSpecResponseSchema>;

/**
 * Schema for updating the spec (user editing)
 */
export const UpdateSpecRequestSchema = z.object({
  spec: z.string().min(10, 'Spec must be at least 10 characters'),
});
export type UpdateSpecRequest = z.infer<typeof UpdateSpecRequestSchema>;

/**
 * Schema for approving a spec
 */
export const ApproveSpecRequestSchema = z.object({
  // If provided, use this as the final spec (in case user made last-minute edits)
  final_spec: z.string().optional(),
});
export type ApproveSpecRequest = z.infer<typeof ApproveSpecRequestSchema>;

/**
 * Schema for the approve-spec endpoint response
 */
export const ApproveSpecResponseSchema = z.object({
  status: z.literal('approved'),
  task_status: TaskStatusSchema,
  message: z.string(),
});
export type ApproveSpecResponse = z.infer<typeof ApproveSpecResponseSchema>;
