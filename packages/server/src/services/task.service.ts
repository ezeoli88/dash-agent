import { v4 as uuidv4 } from 'uuid';
import { getDatabase, saveDatabase } from '../db/database.js';
import { createLogger } from '../utils/logger.js';
import type { CreateTaskInput, UpdateTaskInput, TaskStatus } from '../schemas/task.schema.js';

const logger = createLogger('task-service');

/**
 * Task entity representing a development task for the AI agent.
 * Updated for the two-agent workflow (PM Agent + Dev Agent).
 */
export interface Task {
  /** Unique identifier (UUID) */
  id: string;
  /** Short feature name */
  title: string;
  /** Detailed description (prompt for agent) */
  description: string;
  /** Repository URL (e.g., https://github.com/user/repo) */
  repo_url: string;
  /** Base branch for the task (default: "main") */
  target_branch: string;
  /** Optional: files the agent should review first */
  context_files: string[];
  /** Optional: build command to verify changes */
  build_command: string | null;

  // Two-agent workflow fields
  /** Link to repositories table */
  repository_id: string | null;
  /** Raw user idea/request (Step 1 - Draft) */
  user_input: string | null;
  /** Spec generated by PM Agent (Step 2 - Spec Generation) */
  generated_spec: string | null;
  /** When the spec was generated */
  generated_spec_at: string | null;
  /** Final approved spec, may be edited by user (Step 3 - Approval) */
  final_spec: string | null;
  /** When the spec was approved */
  spec_approved_at: string | null;
  /** True if user modified the generated spec */
  was_spec_edited: boolean;
  /** Branch name created by Dev Agent (Step 4 - Coding) */
  branch_name: string | null;
  /** PR number on GitHub */
  pr_number: number | null;

  /** CLI agent type override for this task */
  agent_type: string | null;
  /** CLI agent model override for this task */
  agent_model: string | null;
  /** Persisted changes/diff data (JSON) so diffs survive worktree cleanup */
  changes_data: string | null;

  /** Current status of the task */
  status: TaskStatus;
  /** URL of the created PR (when status is 'pr_created' or later) */
  pr_url: string | null;
  /** Error message if the task failed */
  error: string | null;

  /** ISO timestamp when the task was created */
  created_at: string;
  /** ISO timestamp when the task was last updated */
  updated_at: string;
}

export type { CreateTaskInput, UpdateTaskInput, TaskStatus };

/**
 * Column names for the tasks table, in order (including new two-agent columns).
 */
const TASK_COLUMNS = [
  'id',
  'title',
  'description',
  'repo_url',
  'target_branch',
  'context_files',
  'build_command',
  'status',
  'pr_url',
  'error',
  'created_at',
  'updated_at',
  // New two-agent workflow columns
  'repository_id',
  'user_input',
  'generated_spec',
  'generated_spec_at',
  'final_spec',
  'spec_approved_at',
  'was_spec_edited',
  'branch_name',
  'pr_number',
  'agent_type',
  'agent_model',
  'changes_data',
] as const;

/**
 * Allowed columns for UPDATE operations (whitelist to prevent SQL injection).
 */
const ALLOWED_UPDATE_COLUMNS = new Set([
  'title',
  'description',
  'repo_url',
  'target_branch',
  'context_files',
  'build_command',
  'status',
  'pr_url',
  'error',
  // New two-agent workflow columns
  'repository_id',
  'user_input',
  'generated_spec',
  'generated_spec_at',
  'final_spec',
  'spec_approved_at',
  'was_spec_edited',
  'branch_name',
  'pr_number',
  'agent_type',
  'agent_model',
  'changes_data',
]);

/**
 * Safely parses a JSON array string, returning empty array on failure.
 */
function safeParseJsonArray(value: string | null | undefined): string[] {
  if (!value) return [];
  try {
    const parsed = JSON.parse(value) as unknown;
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

/**
 * Converts a sql.js result row (array) to a Task object.
 * Updated to handle new two-agent workflow columns.
 */
function rowToTask(values: (string | number | null | Uint8Array)[]): Task {
  return {
    id: values[0] as string,
    title: values[1] as string,
    description: values[2] as string,
    repo_url: values[3] as string,
    target_branch: values[4] as string,
    context_files: safeParseJsonArray(values[5] as string),
    build_command: values[6] as string | null,
    status: values[7] as TaskStatus,
    pr_url: values[8] as string | null,
    error: values[9] as string | null,
    created_at: values[10] as string,
    updated_at: values[11] as string,
    // New two-agent workflow columns (may be null for older tasks)
    repository_id: (values[12] as string | null) ?? null,
    user_input: (values[13] as string | null) ?? null,
    generated_spec: (values[14] as string | null) ?? null,
    generated_spec_at: (values[15] as string | null) ?? null,
    final_spec: (values[16] as string | null) ?? null,
    spec_approved_at: (values[17] as string | null) ?? null,
    was_spec_edited: ((values[18] as number | null) ?? 0) === 1,
    branch_name: (values[19] as string | null) ?? null,
    pr_number: (values[20] as number | null) ?? null,
    agent_type: (values[21] as string | null) ?? null,
    agent_model: (values[22] as string | null) ?? null,
    changes_data: (values[23] as string | null) ?? null,
  };
}

/**
 * Service class for managing tasks.
 */
export class TaskService {
  /**
   * Creates a new task with the given input.
   * Supports both legacy workflow and new two-agent workflow.
   */
  create(input: CreateTaskInput): Task {
    const db = getDatabase();
    const id = uuidv4();
    const now = new Date().toISOString();

    const contextFiles = JSON.stringify(input.context_files ?? []);

    // Determine if this is a two-agent workflow task
    const isTwoAgentWorkflow = Boolean(input.repository_id && input.user_input);

    // For two-agent workflow, generate title from user_input
    let title = input.title ?? '';
    let description = input.description ?? '';

    if (isTwoAgentWorkflow && !title) {
      // Generate a title from the user input (first 50 chars)
      const userInput = input.user_input ?? '';
      title = userInput.length > 50 ? userInput.slice(0, 47) + '...' : userInput;
    }

    if (isTwoAgentWorkflow && !description) {
      // Use user input as description
      description = input.user_input ?? '';
    }

    // Set initial status based on workflow type
    const initialStatus: TaskStatus = isTwoAgentWorkflow ? 'draft' : 'backlog';

    logger.info('Creating task', { id, title, workflow: isTwoAgentWorkflow ? 'two-agent' : 'legacy' });

    db.run(
      `INSERT INTO tasks (
        id, title, description, repo_url, target_branch, context_files, build_command,
        status, created_at, updated_at,
        repository_id, user_input, was_spec_edited,
        agent_type, agent_model
      )
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        title,
        description,
        input.repo_url ?? '',
        input.target_branch ?? 'main',
        contextFiles,
        input.build_command ?? null,
        initialStatus,
        now,
        now,
        // New two-agent workflow fields
        input.repository_id ?? null,
        input.user_input ?? null,
        0, // was_spec_edited defaults to false
        // CLI agent configuration overrides
        input.agent_type ?? null,
        input.agent_model ?? null,
      ]
    );

    saveDatabase();

    const task = this.getById(id);
    if (task === null) {
      throw new Error('Failed to create task');
    }

    logger.info('Task created successfully', { id, status: initialStatus });
    return task;
  }

  /**
   * Retrieves all tasks, ordered by creation date (newest first).
   * Optionally filter by repository_id.
   */
  getAll(repositoryId?: string): Task[] {
    const db = getDatabase();
    logger.debug('Fetching all tasks', { repositoryId });

    let sql = `SELECT ${TASK_COLUMNS.join(', ')} FROM tasks`;
    const params: string[] = [];

    if (repositoryId) {
      sql += ' WHERE repository_id = ?';
      params.push(repositoryId);
    }

    sql += ' ORDER BY created_at DESC';

    const result = db.exec(sql, params);
    if (result.length === 0 || result[0] === undefined) {
      return [];
    }

    return result[0].values.map(rowToTask);
  }

  /**
   * Retrieves a task by its ID.
   * Returns null if the task doesn't exist.
   */
  getById(id: string): Task | null {
    const db = getDatabase();
    logger.debug('Fetching task by ID', { id });

    const stmt = db.prepare(`SELECT ${TASK_COLUMNS.join(', ')} FROM tasks WHERE id = ?`);
    stmt.bind([id]);

    if (!stmt.step()) {
      stmt.free();
      return null;
    }

    const values = stmt.get();
    stmt.free();

    if (!values || values.length === 0) {
      return null;
    }

    return rowToTask(values);
  }

  /**
   * Updates a task with the given input.
   * Returns the updated task, or null if the task doesn't exist.
   */
  update(id: string, input: UpdateTaskInput): Task | null {
    const db = getDatabase();
    logger.info('Updating task', { id, fields: Object.keys(input) });

    const existing = this.getById(id);
    if (existing === null) {
      logger.warn('Task not found for update', { id });
      return null;
    }

    const entries: [string, string | number | null][] = [];
    for (const [key, value] of Object.entries(input)) {
      if (value !== undefined && ALLOWED_UPDATE_COLUMNS.has(key)) {
        let processedValue: string | number | null;

        if (key === 'context_files') {
          processedValue = JSON.stringify(value);
        } else if (key === 'was_spec_edited') {
          processedValue = value ? 1 : 0;
        } else {
          processedValue = value as string | number | null;
        }

        entries.push([key, processedValue]);
      }
    }

    if (entries.length === 0) {
      return existing;
    }

    const sets = entries.map(([k]) => `${k} = ?`).join(', ');
    const values = entries.map(([_, v]) => v);

    const sql = `UPDATE tasks SET ${sets}, updated_at = ? WHERE id = ?`;
    const params = [...values, new Date().toISOString(), id];

    logger.debug('Executing UPDATE', { sql, params, id });

    try {
      db.run(sql, params);
    } catch (error) {
      logger.error('UPDATE failed', { id, error });
      throw error;
    }

    // Verify the update was applied by checking the row count
    const changes = db.getRowsModified();
    logger.debug('Rows modified by UPDATE', { id, changes });

    if (changes === 0) {
      logger.warn('No rows modified by UPDATE - task may not exist', { id });
    }

    // Save to disk immediately after update
    saveDatabase();

    // Fetch and return the updated task
    const updatedTask = this.getById(id);

    if (updatedTask) {
      // Log the actual status to help debug sync issues
      logger.info('Task updated successfully', {
        id,
        newStatus: updatedTask.status,
        updatedAt: updatedTask.updated_at
      });
    }

    return updatedTask;
  }

  /**
   * Deletes a task by its ID.
   * Returns true if the task was deleted, false if it didn't exist.
   */
  delete(id: string): boolean {
    const db = getDatabase();
    logger.info('Deleting task', { id });

    // Check if task exists first
    const existing = this.getById(id);
    if (existing === null) {
      logger.warn('Task not found for deletion', { id });
      return false;
    }

    db.run('DELETE FROM tasks WHERE id = ?', [id]);
    saveDatabase();

    logger.info('Task deleted successfully', { id });
    return true;
  }

  /**
   * Retrieves tasks by status.
   */
  getByStatus(status: TaskStatus): Task[] {
    const db = getDatabase();
    logger.debug('Fetching tasks by status', { status });

    const stmt = db.prepare(`SELECT ${TASK_COLUMNS.join(', ')} FROM tasks WHERE status = ? ORDER BY created_at DESC`);
    stmt.bind([status]);

    const tasks: Task[] = [];
    while (stmt.step()) {
      const values = stmt.get();
      if (values && values.length > 0) {
        tasks.push(rowToTask(values));
      }
    }
    stmt.free();

    return tasks;
  }

  /**
   * Retrieves tasks by repository ID.
   */
  getByRepositoryId(repositoryId: string): Task[] {
    const db = getDatabase();
    logger.debug('Fetching tasks by repository', { repositoryId });

    const stmt = db.prepare(`SELECT ${TASK_COLUMNS.join(', ')} FROM tasks WHERE repository_id = ? ORDER BY created_at DESC`);
    stmt.bind([repositoryId]);

    const tasks: Task[] = [];
    while (stmt.step()) {
      const values = stmt.get();
      if (values && values.length > 0) {
        tasks.push(rowToTask(values));
      }
    }
    stmt.free();

    return tasks;
  }

  /**
   * Updates the spec for a task (PM Agent generated or user edited).
   */
  updateSpec(id: string, spec: string, isGenerated: boolean): Task | null {
    const now = new Date().toISOString();

    if (isGenerated) {
      // PM Agent generated the spec
      return this.update(id, {
        generated_spec: spec,
        generated_spec_at: now,
        final_spec: spec, // Copy to final_spec initially
        status: 'pending_approval',
      });
    } else {
      // User edited the spec
      return this.update(id, {
        final_spec: spec,
        was_spec_edited: true,
      });
    }
  }

  /**
   * Approves the spec and moves task to 'approved' status.
   */
  approveSpec(id: string, finalSpec?: string): Task | null {
    const existing = this.getById(id);
    if (!existing) return null;

    const now = new Date().toISOString();
    const spec = finalSpec ?? existing.final_spec ?? existing.generated_spec;

    if (!spec) {
      throw new Error('No spec to approve');
    }

    // Check if the spec was edited by comparing with generated_spec
    const wasEdited = finalSpec ? finalSpec !== existing.generated_spec : existing.was_spec_edited;

    return this.update(id, {
      final_spec: spec,
      spec_approved_at: now,
      was_spec_edited: wasEdited,
      status: 'approved',
      // Update title and description from the spec if they are placeholder values
      title: existing.title || this.extractTitleFromSpec(spec) || 'Untitled Task',
      description: spec, // Use the spec as the description
    });
  }

  /**
   * Extracts a title from a spec (first non-empty line or header).
   */
  private extractTitleFromSpec(spec: string): string | null {
    const lines = spec.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed) {
        // Remove markdown headers
        const title = trimmed.replace(/^#+\s*/, '');
        return title.length > 100 ? title.slice(0, 97) + '...' : title;
      }
    }
    return null;
  }
}

/** Singleton service instance */
export const taskService = new TaskService();

export default taskService;
